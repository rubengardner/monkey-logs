# Story 2.5: Update Exercise Log

## Status

Draft

## Story

**As a** developer,
**I want** a `PATCH /logs/exercise/{log_id}` endpoint,
**so that** a client application can update the details of a previously recorded `ExerciseLog`.

## Acceptance Criteria

1.  A `PATCH` request to `/logs/exercise/{log_id}` with a JSON body containing the fields to be updated successfully modifies the specified `ExerciseLog` in the database.
2.  The endpoint must be protected, returning `401 Unauthorized` if the user is not authenticated.
3.  If the `log_id` does not exist, the endpoint must return a `404 Not Found`.
4.  If the authenticated user is not the owner of the log (i.e., they don't own the parent `Workout`), the endpoint must return a `403 Forbidden`.
5.  The request must fail with a `422 Unprocessable Entity` if the updated data is invalid (e.g., the `sets` payload doesn't match the schema for the log's `exerciseType`).
6.  A successful request returns a `200 OK` status code with the full, updated `ExerciseLog` object.

## Tasks / Subtasks

*   `[ ]` **Task 1: Create a Pydantic model for the update request.** (AC: #1)
    *   `[ ]` Subtask 1.1: Create an `ExerciseLogUpdate` model where all fields (`workoutId`, `sets`, `notes`, etc.) are optional. This allows the client to send only the data that has changed.
*   `[ ]` **Task 2: Implement the `PATCH /logs/exercise/{log_id}` endpoint.** (AC: #1, #2)
    *   `[ ]` Subtask 2.1: Add the new `PATCH` endpoint with a `log_id` path parameter to the `apps/api/routers/exercise_logs.py` router.
    *   `[ ]` Subtask 2.2: Ensure the endpoint is protected by the `get_current_user` dependency.
*   `[ ]` **Task 3: Implement the update service and repository logic.** (AC: #1, #3, #4, #5)
    *   `[ ]` Subtask 3.1: Create an `update_log` method in the `ExerciseLogService`.
    *   `[ ]` Subtask 3.2: The service must first fetch the existing `ExerciseLog` from the repository using the `log_id`.
    *   `[ ]` Subtask 3.3: It must then verify that the authenticated user owns the workout associated with the log.
    *   `[ ]` Subtask 3.4: The service will apply the partial updates from the request body to the database model and save the changes.
*   `[ ]` **Task 4: Write tests for the update endpoint.**
    *   `[ ]` Subtask 4.1: Write an integration test for a successful partial update (e.g., changing only the `notes` field).
    *   `[ ]` Subtask 4.2: Write an integration test for updating the `sets` array.
    *   `[ ]` Subtask 4.3: Write tests for the failure cases: `404 Not Found`, `403 Forbidden`, and `422 Unprocessable Entity`.

## Dev Notes

*   **Handling Partial Updates:** The core of a `PATCH` implementation is applying partial data. In your `ExerciseLogService`, the `update_log` method should first fetch the existing `ExerciseLog` object from the database. Then, iterate through the fields provided in the `ExerciseLogUpdate` request model and update the attributes on the existing database object before committing the changes.
*   **Pydantic `exclude_unset`:** When working with the `ExerciseLogUpdate` request model, calling `update_data.dict(exclude_unset=True)` is a useful pattern. It returns a dictionary containing only the fields that were explicitly sent in the request body, making it easy to loop over just the changed data.
*   **Authorization:** The authorization check is paramount. Before applying any updates, your service must verify that the `user_id` of the authenticated user matches the `user_id` on the parent `Workout` of the `ExerciseLog` being updated.
*   **Dependencies:** The tests for this story will require data to exist. They should first create a user, a workout, and an exercise log, and then attempt to update that log.

## Change Log

| Date | Version | Description | Author |
| :--- | :--- | :--- | :--- |
| 2025-09-23 | 1.0 | Initial draft | Sarah |
